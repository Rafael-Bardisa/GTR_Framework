//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
multiphong basic.vs multiphong.fs
singlephong basic.vs singlephong.fs

\basic.vs


attribute vec3 a_vertex;
attribute vec3 a_normal;
attribute vec2 a_coord;
attribute vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\flat.fs


uniform vec4 u_color;

void main()
{
	gl_FragColor = u_color;
}


\texture.fs

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture2D( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	gl_FragColor = color;
}

\multiphong.fs

//multipass phong

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

uniform vec3 u_camera_pos;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

//from the light types
uniform int u_light_type;

uniform vec3 u_ambient_light;

uniform vec3 u_light_position;
uniform vec3 u_light_color;
uniform vec3 u_light_direction;


uniform float u_max_distance;

uniform float u_cone_angle_cos;
uniform float u_cone_exp;

uniform bool u_use_alpha;

float spot_factor(vec3 light_direction, vec3 L, float cos_limit, float cone_exp){
        float light_dot = -dot(light_direction, L);
        if (light_dot < cos_limit){
            return 0.0;
            }
        else{
            light_dot = (light_dot - cos_limit)/(1.0-cos_limit);
            return pow(light_dot, cone_exp);
        }
}

void main()
{
    if (u_light_type == 0)
        discard;
        
    vec2 uv = v_uv;
    vec4 color = u_color;
    color *= texture2D( u_texture, uv );
    
    if(color.a < u_alpha_cutoff)
        discard;
        
    vec3 light = u_ambient_light;
    
    //very important to normalize as they come
    //interpolated so normalization is lost
    vec3 N = normalize( v_normal );
    
    float att_factor = 1.0;
    vec3 L = u_light_direction;
    
    if (u_light_type != 3){
    //compute att factor and L if light is not directional
        L = u_light_position - v_world_position;
        float light_distance = length(L);
        L /= light_distance;
        
        att_factor =  u_max_distance - light_distance;
        att_factor = max(att_factor / u_max_distance, 0.0);
        att_factor = pow(att_factor, 2.0);
    }else{
    L = normalize(L);
    }



    float NdotL = clamp(dot(N, L), 0.0, 1.0);
    float spot_factor = 1.0;
    
    if (u_light_type == 2){
    //spot factor if light is spot
    spot_factor = spot_factor(u_light_direction, L, u_cone_angle_cos, u_cone_exp);
    }

    //store the amount of diffuse light
    light += u_light_color * NdotL * att_factor * spot_factor;

    // if it is the first pass we use the color alpha. If not we set it to 0 to avoid adding alpha
    float alpha = u_use_alpha ? color.a : 0.0;
    gl_FragColor = vec4(color.xyz * light, alpha);
}

\singlephong.fs

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;
varying vec4 v_color;

uniform vec3 u_camera_pos;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

void main()
{
    vec2 uv = v_uv;
    vec3 L = u_camera_pos - v_world_position;
    vec4 color = u_color;
    color *= texture2D( u_texture, uv );

    if(color.a < u_alpha_cutoff)
        discard;

    gl_FragColor = color;
}

\quad.vs

attribute vec3 a_vertex;
attribute vec2 a_coord;
varying vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}


\multi.fs

#version 330 core

varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	gl_FragData[0] = color;
	gl_FragData[1] = vec4(N,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
varying vec2 v_uv;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	gl_FragColor = vec4(color);
}

\instanced.vs


attribute vec3 a_vertex;
attribute vec3 a_normal;
attribute vec2 a_coord;

attribute mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
varying vec3 v_position;
varying vec3 v_world_position;
varying vec3 v_normal;
varying vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}
